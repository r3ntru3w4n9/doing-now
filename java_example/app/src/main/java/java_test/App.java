/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package java_test;

import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.util.Arrays;

import com.google.gson.Gson;

record Example(StringBuilder sb) {}

public class App {
    public static final class SomeClass<T extends Gson> {
    }

    public static List<Integer> somefunc() {
        return Arrays.asList(new Integer[] { 1, 2, 3, 8 });
    }

    public static void main(String[] args) {
        System.out.println("hello");

        var array = (ArrayList<Integer>) Arrays.asList(new Integer[] { 1, 2, 3 });

        // Java does not have the 'inference by return type' that Rust has.
        // Which is the reason collect takes an argument rather than overloading (static
        // dispatch).
        var list = array.stream().map((var x) -> x + 1).collect(Collectors.toList());
        System.out.println(list);

        var l = App.somefunc();
        System.out.println(l);

        // Serialization
        var gson = new Gson();
        System.out.println(gson.toJson(1));
        System.out.println(gson.toJson("abcd"));
        System.out.println(gson.toJson(10));
        int[] values = { 1 };
        System.out.println(gson.toJson(values));

        // Deserialization
        int one1 = gson.fromJson("1", int.class);
        Integer one2 = gson.fromJson("1", Integer.class);
        Long one3 = gson.fromJson("1", Long.class);
        Boolean false0 = gson.fromJson("false", Boolean.class);
        String str = gson.fromJson("\"abc\"", String.class);
        String[] anotherStr = gson.fromJson("[\"abc\"]", String[].class);

        System.out.printf("%d, %d, %d, %b, %s, %s\n", one1, one2, one3, false0, str, anotherStr.toString());

        var ex = new Example(new StringBuilder(""));
        ex.sb().append("2qpeiobq");
        System.out.println(ex.sb());
    }
}
